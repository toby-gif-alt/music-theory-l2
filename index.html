<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NCEA L2 (AS91276) Question Generator</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <!-- Load VexFlow from CDN (window.Vex.Flow available after load). -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <style>
    :root{
      --bg:#0f172a; --panel:#0b1224; --panel2:#101a33; --muted:#94a3b8; --text:#e5e7eb; --acc:#22d3ee; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;line-height:1.5;background:linear-gradient(180deg,#0b1224,#0f172a 30%,#0b1224 100%);color:var(--text)}
    header{position:sticky;top:0;background:rgba(15,23,42,.75);backdrop-filter:blur(8px);border-bottom:1px solid #1f2937}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    h1{margin:0;font-size:1.35rem;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:.92rem}
    main{padding:20px 0}
    .grid{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:1000px){.grid{grid-template-columns:340px 1fr}}
    .card{background:linear-gradient(180deg,#0b1224,#0f1830);border:1px solid #1f2937;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .card .pad{padding:16px}
    .card h2{margin:0 0 8px;font-size:1.05rem}
    label{display:block;margin:10px 0 4px;color:#cbd5e1;font-size:.9rem}
    select,input,textarea,button{width:100%;padding:10px 12px;border-radius:12px;border:1px solid #374151;background:#0b1224;color:#e5e7eb}
    textarea{min-height:120px;resize:vertical}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
    .btn{cursor:pointer;border:1px solid #334155;background:linear-gradient(180deg,#101a33,#0e162c);transition:transform .04s ease, box-shadow .2s ease}
    .btn:hover{box-shadow:0 0 0 1px #334155,0 6px 16px rgba(0,0,0,.35)}
    .btn:active{transform:translateY(1px)}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid #334155;color:#cbd5e1;font-size:.8rem}
    .tag{padding:2px 8px;border-radius:999px;background:#0b1224;border:1px solid #334155;color:#a5b4fc}
    .qbox{border-top:1px dashed #334155;margin-top:12px;padding-top:12px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Monospace}
    .answer{border-left:4px solid var(--acc);padding:8px 12px;background:#0b1224;border-radius:8px;margin-top:10px;white-space:pre-wrap}
    .muted{color:var(--muted)}
    .flex{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .right{text-align:right}
    .small{font-size:.85rem}
    .ok{color:var(--ok)}.warn{color:var(--warn)}.bad{color:var(--bad)}
    .hl{color:#a5b4fc}
    .printable h3{margin:.6rem 0}
    .twin{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media print{header,.controls{display:none}body{background:#fff;color:#000}.card{border:none;box-shadow:none}.printable{page-break-before:always}}
    .kbd{font-family:ui-monospace,Monaco,Consolas;background:#0b1224;border:1px solid #334155;border-radius:6px;padding:2px 6px}
    .vfwrap { background:#fff; border:1px solid #e5e7eb; border-radius:10px; padding:8px; overflow:auto; }
    .vfwrap svg { display:block; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>AS91276 Question Generator <span class="tag">v2</span></h1>
      <div class="sub">NZQA Level 2 Music – <em>Demonstrate knowledge of conventions in a range of music scores</em>. Single‑file app – host as <span class="kbd">index.html</span> on GitHub Pages.</div>
    </div>
  </header>

  <main class="wrap grid">
    <!-- LEFT: controls -->
    <section class="card">
      <div class="pad">
        <h2>Build a pack</h2>
        <label>Topics (choose one or more)</label>
        <select id="topics" multiple size="5">
          <option value="qIntervals">Intervals (quality + quantity)</option>
          <option value="qTransposition">Transposition (Bb/Eb/F to concert & back)</option>
          <option value="qTonality">Tonality (key + evidence, modulation)</option>
          <option value="qHarmony">Harmony (chord symbols, inversions)</option>
          <option value="qCadences">Cadences (ID + bass/7th logic – text)</option>
        </select>

        <label>Difficulty mapping</label>
        <select id="difficulty">
          <option value="A">Achievement – identify / describe</option>
          <option value="M">Merit – explain / give evidence</option>
          <option value="E">Excellence – analyse / apply with effect</option>
        </select>

        <div class="row">
          <label>How many questions?</label>
          <input id="qty" type="number" min="1" max="50" value="10" />
        </div>

        <div class="row3">
          <button class="btn" id="gen">Generate</button>
          <button class="btn" id="clear">Clear</button>
          <button class="btn" id="print">Print / Save PDF</button>
        </div>

        <h2 style="margin-top:16px">Rubric helper</h2>
        <div class="small muted">
          <ul>
            <li><span class="hl">A</span> – identify / name / describe items correctly.</li>
            <li><span class="hl">M</span> – explain with specific <em>evidence</em> from the score (underlined‑type cues).</li>
            <li><span class="hl">E</span> – analyse/apply and discuss <em>effect on performance / sound</em> (bold‑type cues).</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- RIGHT: output -->
    <section class="card">
      <div class="pad">
        <h2>Output</h2>
        <div id="out"></div>
        <div id="schedule"></div>
      </div>
    </section>
  </main>

  <script type="module">
document.addEventListener('DOMContentLoaded', async () => {
  // --- Ensure VexFlow is present ---
  const VF = window.Vex && window.Vex.Flow;
  if (!VF) {
    console.error('VexFlow not loaded. Check the <script src> in <head>.');
    alert('VexFlow failed to load. Check the CDN URL.');
    return;
  }

  // VexFlow v4 uses HorizontalJustify / VerticalJustify; v3 used Justify / VerticalJustify on the class.
  const HJ = (VF.Annotation && (VF.Annotation.HorizontalJustify || VF.Annotation.Justify)) || { LEFT:1, CENTER:2, RIGHT:3, CENTER_STEM:4 };
  const VJ = (VF.Annotation && (VF.Annotation.VerticalJustify || VF.Annotation.VerticalJustify)) || { TOP:1, CENTER:2, BOTTOM:3, CENTER_STEM:4 };

  // Helper to style notes and accidentals red
  function colorRed(obj){
    if (obj && typeof obj.setStyle === 'function') {
      obj.setStyle({ fillStyle: 'red', strokeStyle: 'red' });
    }
  }

  // --- Sanity check: test VexFlow rendering ---
  // This test is currently ACTIVE. Comment out the entire try/catch block after verification.
  
  try {
    const testDiv = document.createElement('div');
    testDiv.id = 'vf-sanity-test';
    testDiv.style.marginBottom = '20px';
    testDiv.style.padding = '10px';
    testDiv.style.border = '2px solid #22d3ee';
    document.getElementById('out').prepend(testDiv);
    
    // Create factory after element is in DOM
    const factory = new VF.Factory({ renderer: { elementId: "vf-sanity-test", width: 600, height: 200 }});
    const score = factory.EasyScore();
    const system = factory.System();
    const notes = score.notes("C4/q, D4, E4, F4");
    const voice = score.voice(notes);
    system.addStave({ voices: [voice] }).addClef("treble").addTimeSignature("4/4");
    factory.draw();
    console.log('VexFlow sanity check passed!');
  } catch (error) {
    console.error('VexFlow sanity check failed:', error);
    alert('VexFlow sanity check failed: ' + error.message);
  }
  

  // --- Load mined data ---
  const fetchJSON = (url, fallback) => fetch(url).then(r => r.ok ? r.json() : fallback).catch(() => fallback);
  const banks = await fetchJSON('data/banks.json', {
    intervalQualities: ["minor","major","perfect","diminished","augmented"],
    intervalNumbers: ["2nd","3rd","4th","5th","6th","7th","octave"],
    keys: ["C","G","D","A","E","B","F#","F","Bb","Eb","Ab","Db"],
    modes: ["major","minor"],
    cadenceTypes: ["perfect (V-I)","plagal (IV-I)","imperfect (any-V)","interrupted (V-vi)"],
    devices: [["sequence","repeat motif higher/lower"],["ostinato","repeated motif"],["inversion","intervals inverted"],["augmentation","note values longer"],["diminution","note values shorter"]],
    perf: [["staccato","short, detached"],["tenuto","slightly longer"],["marcato","accented"],["accent","emphasised"],["legato","smooth, connected"]],
    instruments: { Bb:["Clarinet in Bb","Trumpet in Bb"], Eb:["Alto Sax in Eb","Baritone Sax in Eb"], F:["Horn in F"] }
  });
  const patterns = await fetchJSON('data/patterns.json', { stems:[], verbs:[], rubric:[] });
  // load the trained bank
  const bank = await fetchJSON('data/question_bank.json', null);

  // helper to pick a stem that matches the topic, falling back to defaults
  function pickStem(topic, fallback) {
    if (!bank) return fallback;
    const pool = (bank.topics && bank.topics[topic])?.length ? bank.topics[topic] : [];
    if (pool.length) return pool[Math.floor(Math.random()*pool.length)];
    // else search raw stems by keyword
    const hit = (bank.stems||[]).filter(s => s.toLowerCase().includes(topic.toLowerCase()));
    return hit.length ? hit[Math.floor(Math.random()*hit.length)] : fallback;
  }

  // --- Helpers (ASCII only) ---
  const pick = a => a[Math.floor(Math.random() * a.length)];
  const cap  = s => s.charAt(0).toUpperCase() + s.slice(1);
  const el   = id => document.getElementById(id);
  const DIFF = {
    A: s => "Identify / describe: " + s,
    M: s => "Explain with evidence from the score: " + s,
    E: s => "Analyse/apply and discuss the effect on the music: " + s
  };

  // --- VexFlow helpers ---
  function vfFactory(containerId, size) {
    const width  = (size && size.width)  || 560;
    const height = (size && size.height) || 160;
    return new VF.Factory({ renderer: { elementId: containerId, width, height }});
  }
  function drawSystem(factory, opts) {
    const clef   = (opts && opts.clef)   || "treble";
    const keySig = (opts && opts.keySig) || "C";
    const timeSig= (opts && opts.timeSig)|| "4/4";
    const score  = factory.EasyScore();
    const system = factory.System();
    const stave  = system.addStave({ voices: [] });
    stave.addClef(clef).addKeySignature(keySig).addTimeSignature(timeSig);
    return { score, system, stave };
  }
  function randInt(a, b){ return Math.floor(Math.random() * (b - a + 1)) + a; }
  function randNoteTreble(){ return pick(["c","d","e","f","g","a","b"]) + "/" + randInt(4,5); }
  function semitoneOffset(note, semi){
    const parts = note.split("/");
    const letter = parts[0], oct = parseInt(parts[1], 10);
    const pcMap = {c:0,d:2,e:4,f:5,g:7,a:9,b:11};
    const base  = pcMap[letter] + 12*oct;
    const midi  = base + semi;
    const outOct = Math.floor(midi/12);
    const pcs = {c:0,"c#":1,d:2,"d#":3,e:4,f:5,"f#":6,g:7,"g#":8,a:9,"a#":10,b:11};
    let name = "c";
    for (const k in pcs){ if (pcs[k] === (midi % 12 + 12) % 12) { name = k; break; } }
    const acc = name.indexOf("#") >= 0 ? "#" : null;
    return { letter: name.replace("#","").toUpperCase(), acc, oct: outOct };
  }
  function toEasyToken(obj, dur){ // e.g. {letter:'C', acc:'#', oct:4} -> "C#4/8"
    const acc = obj.acc ? obj.acc : "";
    return obj.letter + acc + obj.oct + "/" + dur;
  }

  // --- Engraving builders (no nested backticks) ---
  // A) Intervals: 6 harmonic (vertical) interval pairs -> 4/4
  function engraveIntervals(containerId){
    const factory = new VF.Factory({ renderer: { elementId: containerId, width: 560, height: 170 }});
    const system = factory.System();

    const keys = (banks.keys && banks.keys.length) ? banks.keys : ['C'];
    const keySig = keys[Math.floor(Math.random()*keys.length)];

    const qualities = banks.intervalQualities || ['minor','major','perfect','diminished','augmented'];
    const numbers   = banks.intervalNumbers  || ['2nd','3rd','4th','5th','6th','7th','octave'];
    const semisMap  = { '2nd':2,'3rd':4,'4th':5,'5th':7,'6th':9,'7th':11,'octave':12 };

    const notes = []; // Array of StaveNote objects with multiple keys (harmonic intervals)
    for (let i=1;i<=6;i++){
      const aKey = randNoteTreble(); // e.g. "c/4"
      const q = qualities[Math.floor(Math.random()*qualities.length)];
      const n = numbers[Math.floor(Math.random()*numbers.length)];
      const step = semisMap[n] || 7;
      const adjust = (q==='minor') ? -1 : (q==='augmented') ? +1 : (q==='diminished') ? -1 : 0;
      const semi = step + adjust;

      // Convert to note format for VexFlow
      const lowerNote = aKey.toUpperCase().replace('/', ''); // "C4"
      const upperObj = semitoneOffset(aKey, semi);
      const upperNote = upperObj.letter + (upperObj.acc || '') + upperObj.oct; // "E4"
      
      // Create harmonic interval: both notes sounding together
      const harmonic = new VF.StaveNote({
        clef: 'treble',
        keys: [lowerNote, upperNote],
        duration: 'q'
      });
      
      // Add accidentals if needed
      if (upperObj.acc) {
        harmonic.addModifier(new VF.Accidental(upperObj.acc), 1);
      }
      
      colorRed(harmonic);
      
      // Add label number
      const ann = new VF.Annotation(String(i));
      ann.setFont('Arial', 10);
      ann.setJustification(HJ.CENTER);
      ann.setVerticalJustification(VJ.TOP);
      harmonic.addModifier(ann, 0);
      
      notes.push(harmonic);
    }

    const voice = new VF.Voice({ num_beats: 6, beat_value: 4 }).addTickables(notes);
    const stave = system.addStave({ voices:[voice] });
    stave.addClef('treble').addKeySignature(keySig).addTimeSignature('6/4');

    new VF.Formatter().joinVoices([voice]).format([voice], 480);
    factory.draw();
  }

  // B) Transposition: actual musical phrase with varied rhythms -> 4/4
  function engraveTransposition(containerId){
    const factory = new VF.Factory({ renderer: { elementId: containerId, width: 560, height: 170 }});
    const score = factory.EasyScore();
    const system = factory.System();

    const keys = (banks.keys && banks.keys.length) ? banks.keys : ['C'];
    const keySig = keys[Math.floor(Math.random()*keys.length)];
    
    // Use a coherent musical phrase with varied rhythms
    const tokens = 'C4/q, D4/q, E4/q, F4/q, G4/h';

    const notes = score.notes(tokens);
    notes.forEach(colorRed);
    const voice = score.voice(notes, { time: '4/4' });

    const stave = system.addStave({ voices:[voice] });
    stave.addClef('treble').addKeySignature(keySig).addTimeSignature('4/4');

    factory.draw();
  }

  // C) Tonality: 2-bar phrase with varied rhythms -> 4/4
  function engraveTonality(containerId){
    const factory = new VF.Factory({ renderer: { elementId: containerId, width: 640, height: 180 }});
    const score = factory.EasyScore();
    const system = factory.System();

    const keys = (banks.keys && banks.keys.length) ? banks.keys : ['C'];
    const keySig = keys[Math.floor(Math.random()*keys.length)];
    
    // 2-bar phrase with varied rhythms showing clear cadence
    const bar1 = ['C4/q','D4/q','E4/q','F4/q'];  // Bar 1: quarter notes
    const bar2 = ['G4/h','C4/h'];                // Bar 2: half notes (cadence)
    const tokens = bar1.concat(bar2).join(', ');

    const notes = score.notes(tokens);
    notes.forEach(colorRed);
    const voice = score.voice(notes, { time: '4/4' });

    const stave = system.addStave({ voices:[voice] });
    stave.addClef('treble').addKeySignature(keySig).addTimeSignature('4/4');

    factory.draw();
  }

  // --- Template-aware engraving functions ---
  function engraveTonalityFromTemplate(containerId, tpl){
    const { key, time, bars } = tpl;
    const VF = window.Vex.Flow;
    const factory = new VF.Factory({ renderer: { elementId: containerId, width: 640, height: 180 }});
    const score = factory.EasyScore();
    const system = factory.System();
    const tokens = bars.flat().join(', '); // flatten array-of-bars into EasyScore tokens
    const notes = score.notes(tokens);
    notes.forEach(colorRed);
    const voice = score.voice(notes, { time: time || '4/4' });
    const stave = system.addStave({ voices:[voice] });
    stave.addClef('treble').addKeySignature(key || 'C').addTimeSignature(time || '4/4');
    factory.draw();
  }

  function engraveCadencesFromTemplate(containerId, tpl){
    const { key, type, seg } = tpl;
    const VF = window.Vex.Flow;
    const factory = new VF.Factory({ renderer: { elementId: containerId, width: 560, height: 170 }});
    const score = factory.EasyScore();
    const system = factory.System();
    const tokens = seg.flat().join(', ');
    const notes = score.notes(tokens);
    notes.forEach(colorRed);
    const voice = score.voice(notes, { time: '4/4' });
    const stave = system.addStave({ voices:[voice] });
    stave.addClef('treble').addKeySignature(key || 'C').addTimeSignature('4/4');
    factory.draw();
  }

  function engraveHarmonyFromTemplate(containerId, tpl){
    const { key, time, roman, bass } = tpl;
    const VF = window.Vex.Flow;
    const factory = new VF.Factory({ renderer: { elementId: containerId, width: 560, height: 170 }});
    const score = factory.EasyScore();
    const system = factory.System();
    const tokens = bass.join(', ');
    const notes = score.notes(tokens);
    notes.forEach(colorRed);
    // Add roman numeral annotations
    notes.forEach((staveNote, idx) => {
      if (idx < roman.length) {
        const ann = new VF.Annotation(roman[idx]);
        ann.setFont('Arial', 10);
        ann.setJustification(HJ.CENTER);
        ann.setVerticalJustification(VJ.BOTTOM);
        staveNote.addModifier(ann, 0);
      }
    });
    const voice = score.voice(notes, { time: time || '4/4' });
    const stave = system.addStave({ voices:[voice] });
    stave.addClef('bass').addKeySignature(key || 'C').addTimeSignature(time || '4/4');
    factory.draw();
  }

  function engraveIntervalsFromTemplate(containerId, tpl){
    // For intervals, we use the template to generate harmonic (vertical) pairs
    const VF = window.Vex.Flow;
    const factory = new VF.Factory({ renderer: { elementId: containerId, width: 560, height: 170 }});
    const system = factory.System();
    
    const keys = (banks.keys && banks.keys.length) ? banks.keys : ['C'];
    const keySig = keys[Math.floor(Math.random()*keys.length)];
    
    const templates = (bank?.templates?.Intervals || []);
    const notes = [];
    
    for (let i=1; i<=6; i++){
      const aKey = randNoteTreble(); // e.g. "c/4"
      const t = templates[Math.floor(Math.random()*templates.length)] || { label:'P5', semi:7 };
      const semi = t.semi || 7;
      
      const lowerNote = aKey.toUpperCase().replace('/', ''); // "C4"
      const upperObj = semitoneOffset(aKey, semi);
      const upperNote = upperObj.letter + (upperObj.acc || '') + upperObj.oct; // "E4"
      
      // Create harmonic interval: both notes sounding together
      const harmonic = new VF.StaveNote({
        clef: 'treble',
        keys: [lowerNote, upperNote],
        duration: 'q'
      });
      
      // Add accidentals if needed
      if (upperObj.acc) {
        harmonic.addModifier(new VF.Accidental(upperObj.acc), 1);
      }
      
      colorRed(harmonic);
      
      // Add label number
      const ann = new VF.Annotation(String(i));
      ann.setFont('Arial', 10);
      ann.setJustification(HJ.CENTER);
      ann.setVerticalJustification(VJ.TOP);
      harmonic.addModifier(ann, 0);
      
      notes.push(harmonic);
    }
    
    const voice = new VF.Voice({ num_beats: 6, beat_value: 4 }).addTickables(notes);
    const stave = system.addStave({ voices:[voice] });
    stave.addClef('treble').addKeySignature(keySig).addTimeSignature('6/4');
    
    new VF.Formatter().joinVoices([voice]).format([voice], 480);
    factory.draw();
  }

  function engraveTranspositionFromTemplate(containerId, tpl){
    const { inst, dir, interval } = tpl;
    const VF = window.Vex.Flow;
    const factory = new VF.Factory({ renderer: { elementId: containerId, width: 560, height: 170 }});
    const score = factory.EasyScore();
    const system = factory.System();
    
    const keys = (banks.keys && banks.keys.length) ? banks.keys : ['C'];
    const keySig = keys[Math.floor(Math.random()*keys.length)];
    
    // Use a coherent musical phrase with varied rhythms from template or default
    const tokens = (tpl.phrase) ? tpl.phrase.join(', ') : 'C4/q, D4/q, E4/q, F4/q, G4/h';
    
    const notes = score.notes(tokens);
    notes.forEach(colorRed);
    const voice = score.voice(notes, { time: '4/4' });
    const stave = system.addStave({ voices:[voice] });
    stave.addClef('treble').addKeySignature(keySig).addTimeSignature('4/4');
    factory.draw();
  }

  // --- Question objects (ASCII only) ---
  const GEN = {
    qIntervals: function(level){
      const stem = pickStem('Intervals', "Identify the quality and quantity of the labelled intervals 1 to 6.");
      const tpl = (bank?.templates?.Intervals||[])[0] || { label:'P5', semi:7 };
      return { topic:"Intervals", stem: DIFF[level](stem), model:"Quality + quantity on each; correct for clef.", render: (id) => engraveIntervalsFromTemplate(id, tpl) };
    },
    qTransposition: function(level){
      const templates = (bank?.templates?.Transposition || []);
      const tpl = templates.length ? templates[Math.floor(Math.random()*templates.length)] : { inst:'Clarinet in Bb', dir:'to concert', interval:'M2 down' };
      const inst = tpl.inst || "Clarinet in Bb";
      const base = "Transpose to concert pitch: " + inst + ". ";
      const addA = "State the interval and direction.";
      const addM = "State the interval, resulting key, and direction.";
      const addE = "Justify key-signature changes and accidentals.";
      const tail = (level === "A") ? addA : (level === "M") ? addM : addE;
      const stem = pickStem('Transposition', base + tail);
      return { topic:"Transposition", stem: DIFF[level](stem), model:"Bb=M2, Eb=M6, F=P5 families.", render: (id) => engraveTranspositionFromTemplate(id, tpl) };
    },
    qTonality: function(level){
      const stem = pickStem('Tonality', "Identify the key and give evidence (for example, V or V7 to I near cadence).");
      const tpl = (bank?.templates?.Tonality||[])[Math.floor(Math.random()*(bank?.templates?.Tonality||[]).length)] || { key:'C', time:'4/4', bars:[['C4/8','D4/8','E4/8','F4/8','G4/8','F4/8','E4/8','C4/8']], cadence:'V–I' };
      return { topic:"Tonality", stem: DIFF[level](stem), model:"Evidence: key signature; V or V7->I; opening/closing chords.", render: (id) => engraveTonalityFromTemplate(id, tpl) };
    },
    qHarmony: function(level){
      const stem = pickStem('Harmony', "Add chord symbols for a 4 bar phrase. Include one inversion.");
      const tpl = (bank?.templates?.Harmony||[])[Math.floor(Math.random()*(bank?.templates?.Harmony||[]).length)] || { key: 'C', time:'4/4', roman:['I','IV','V','I'], bass: ['C3/4','F3/4','G3/4','C3/4'] };
      return { topic:"Harmony", stem: DIFF[level](stem), model:"Derive from bass and melody; include inversion; cadential function.", render: (id) => engraveHarmonyFromTemplate(id, tpl) };
    },
    qCadences: function(level){
      const templates = (bank?.templates?.Cadences || []);
      const tpl = templates.length ? templates[Math.floor(Math.random()*templates.length)] : { key:'D', type:'perfect (V–I)', seg:[['A3/4','D4/4']] };
      const cad = tpl.type || pick(banks.cadenceTypes || ["perfect (V-I)","plagal (IV-I)","imperfect (any-V)","interrupted (V-vi)"]);
      const stem = pickStem('Cadences', "Name the cadence (for example: " + cad + ").");
      return { topic:"Cadences", stem: DIFF[level](stem), model: cad.split(" ")[0] + " cadence; chord tones support label.", render: (id) => engraveCadencesFromTemplate(id, tpl) };
    }
  };
  const TOPIC_KEYS = Object.keys(GEN);

  // --- Schedule text ---
  function scheduleFor(key){
    const base = {
      A: "Identifies or describes correctly.",
      M: "Explains using specific evidence (bars, parts, notation).",
      E: "Analyses and states the effect on performance or sound."
    };
    const special = {
      qIntervals:   { A:"Names quality and quantity for most intervals.", M:"All intervals with workings.", E:"Links dissonance or resolution to effect." },
      qTransposition:{A:"Correct direction and interval.", M:"Resulting key and signature correct.", E:"Justifies signature/accidentals and tessitura impact."},
      qTonality:    { A:"Names plausible key.", M:"Two pieces of evidence (cadence/chords/accidentals).", E:"Notes brief modulation or tonicisation with chord evidence." }
    };
    const sp = special[key] || {};
    return { A: sp.A || base.A, M: sp.M || base.M, E: sp.E || base.E };
  }

  // --- Renderers ---
  function renderExam(qs){
    const out = el('out'); if (!out) return;
    out.innerHTML = "";
    qs.forEach((q,i) => {
      const div = document.createElement('div');
      const vfId = "vf-" + (i+1);
      div.className = "qbox";
      div.innerHTML = "<h3>Q" + (i+1) + " [" + q.topic + "]</h3>"
                    + "<div class=\"mono\">" + q.stem + "</div>"
                    + "<div class=\"vfwrap\"><div id=\"" + vfId + "\"></div></div>";
      out.appendChild(div);
      if (q.render) q.render(vfId);
    });
  }
  function renderSchedule(qs){
    const sc = el('schedule'); if (!sc) return;
    sc.innerHTML = "<h2>Assessment Schedule</h2>";
    qs.forEach((q,i) => {
      const s = scheduleFor(q._key);
      const sec = document.createElement('div');
      sec.className = "qbox";
      sec.innerHTML = "<h3>Q" + (i+1) + " [" + q.topic + "]</h3>"
                    + "<ul>"
                    + "<li><strong>Achievement:</strong> " + s.A + "</li>"
                    + "<li><strong>Merit:</strong> " + s.M + "</li>"
                    + "<li><strong>Excellence:</strong> " + s.E + "</li>"
                    + "</ul>";
      sc.appendChild(sec);
    });
  }

  // --- Main ---
  function buildPack(){
    const topicsSel = el('topics');
    const chosen = topicsSel ? Array.from(topicsSel.selectedOptions).map(o => o.value) : [];
    const keys = chosen.length ? chosen : TOPIC_KEYS;
    const level = (el('difficulty') && el('difficulty').value || "A").toUpperCase();
    const qtyEl = el('qty');
    const n = Math.min(Math.max(parseInt(qtyEl && qtyEl.value, 10) || 8, 1), 30);
    const qs = [];
    for (let i = 0; i < n; i++){
      const k = pick(keys);
      const q = GEN[k](level);
      q._key = k;
      qs.push(q);
    }
    renderExam(qs);
    renderSchedule(qs);
    window._lastQs = qs;
  }

  const btnGen = el('gen'), btnClear = el('clear'), btnPrint = el('print');
  if (btnGen)   btnGen.addEventListener('click', buildPack);
  if (btnClear) btnClear.addEventListener('click', () => { if (el('out')) el('out').innerHTML = ""; if (el('schedule')) el('schedule').innerHTML = ""; });
  if (btnPrint) btnPrint.addEventListener('click', () => window.print());

  // Generate once on load
  buildPack();
});
</script>

</body>
</html>
